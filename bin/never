#!/usr/bin/env node

var IS_NODE = true;
var IS_SPACEPORT = false;

var UPDATE_INTERVAL = 100;
var COLLECT_INTERVAL = 1000;

var path = require('path');
var fs = require('fs');
var util = require('util');

var Q = require('q');
var watch = require('watch');
var v8socket = require('v8-socket');

var rootPath = process.argv[2] || '.';
var port = Number(process.argv[3] || 5858);
var host = process.argv[4] || '';

var socket = v8socket.connect(port, host);

var changeQueue = [ ];
var changeTimeout = null;
var updatePromise = Q.ref(null);

watch.watchTree(rootPath, {
    ignoreDotFiles: true
}, function on_watchEvent(fileName, cur, prev) {
    if (typeof fileName === 'string') {
        var filePath = path.resolve(fileName);
        if (changeQueue.indexOf(filePath) < 0) {
            changeQueue.push(filePath);
            queueUpdateScripts();
        }
    }
});

function collectLiveScripts() {
    return Q.ncall(
        socket.request,
        socket,
        { 'command': 'scripts' }
    ).get(0).then(function (data) {
        var scripts = Object.create(null);

        data.forEach(function (scriptData) {
            if (scriptData['type'] === 'script'
             && scriptData['scriptType'] === 2) {
                var name = scriptData['name'];
                if (typeof name === 'string') {
                    var id = scriptData['id'];

                    if (IS_SPACEPORT) {
                        name = path.basename(name);
                    }

                    scripts[name] = id;
                }
            }
        });

        return scripts;
    });
}

function updateScripts(filePaths) {
    return Q.ncall(socket.pauseWith, socket, function (callback) {
        // Debugger is paused in this function block,
        // as to make updates atomic

        collectLiveScripts().then(function (liveScripts) {
            function readFileContents(filePath, scriptName) {
            }

            function sendContentsToDebugger(scriptName, contents) {
                if (IS_NODE) {
                    contents = '(function (exports, require, module, __filename, __dirname) { ' + contents + '\n});';
                }

                return Q.ncall(socket.request, socket, {
                    'command': 'changelive',
                    'arguments': {
                        'script_id': liveScripts[scriptName],
                        'new_source': contents
                    }
                });
            }

            function updateScript(filePath) {
                var scriptName = filePath;
                if (IS_SPACEPORT) {
                    scriptName = path.basename(filePath);
                }

                if (!(scriptName in liveScripts)) {
                    return null;
                }

                console.log("Updating script " + filePath);

                return Q.ncall(fs.readFile, fs, filePath).then(function (contents) {
                    return sendContentsToDebugger(scriptName, contents);
                }).fail(function (err) {
                    // Add some debugging information to errors
                    err.scriptName = scriptName;
                    err.filePath = filePath;
                    throw err;
                });
            }

            return Q.all(filePaths.map(updateScript));
        }).then(function (_) {
            callback(null);
        }, function (err) {
            callback(err);
        });

        // end debugger stopped
    });
}

function queueUpdateScripts() {
    if (changeTimeout !== null) {
        clearTimeout(changeTimeout);
    }

    changeTimeout = setTimeout(function () {
        updatePromise = updatePromise.then(function () {
            // Remove all files from queue and update them
            var filePaths = changeQueue.splice(0, changeQueue.length);
            updateScripts(filePaths).end();
        }).fail(function (err) {
            console.error(err);
            // Eat error
        });
    }, UPDATE_INTERVAL);
}
