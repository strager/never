#!/usr/bin/env node

var IS_NODE = true;
var IS_SPACEPORT = false;

var UPDATE_INTERVAL = 100;
var COLLECT_INTERVAL = 1000;

var path = require('path');
var fs = require('fs');
var util = require('util');

var Q = require('q');
var watch = require('watch');
var v8socket = require('v8-socket');

var rootPath = process.argv[2] || '.';
var port = Number(process.argv[3] || 5858);
var host = process.argv[4] || '';

var socket = v8socket.connect(port, host);

var liveScripts = Object.create(null); // script path => script ID
var changeQueue = [ ];

var changeTimeout = null;
var updatePromise = Q.ref(null);

watch.watchTree(rootPath, {
    ignoreDotFiles: true
}, function on_watchEvent(fileName, cur, prev) {
    if (typeof fileName === 'string') {
        var filePath = path.resolve(fileName);
        if (changeQueue.indexOf(filePath) < 0) {
            changeQueue.push(filePath);
            queueUpdateScripts();
        }
    }
});

function collectLiveScripts() {
    return Q.ncall(
        socket.request,
        socket,
        { 'command': 'scripts' }
    ).then(function (data) {
        var scripts = Object.create(null);

        data.forEach(function (scriptData) {
            if (scriptData['type'] === 'script'
             && scriptData['scriptType'] === 2) {
                var name = scriptData['name'];
                if (typeof name === 'string') {
                    var id = scriptData['id'];

                    if (IS_SPACEPORT) {
                        name = path.basename(name);
                    }

                    scripts[name] = id;
                }
            }
        });

        return scripts;
    });
}

function updateScripts(filePaths) {
    var scriptNames = filePaths.map(function (filePath) {
        if (IS_SPACEPORT) {
            return path.basename(filePath);
        } else {
            return filePath;
        }
    });

    return Q.all(filePaths.map(function (filePath, i) {
        // Collect contents of each changed script

        if (scriptNames[i] in liveScripts) {
            return Q.ncall(fs.readFile, fs, filePath);
        } else {
            return null;
        }
    })).then(function (contentss) {
        // Send changes to debugger

        return Q.all(contentss.map(function (contents, i) {
            var scriptName = scriptNames[i];

            if (IS_NODE) {
                contents = '(function (exports, require, module, __filename, __dirname) { ' + contents + '\n});';
            }

            return Q.ncall(socket.request, socket, {
                'command': 'changelive',
                'arguments': {
                    'script_id': liveScripts[scriptName],
                    'new_source': contents
                }
            });
        }));
    }).then(function (responses) {
        // Profit!

        return null; // Hide responses
    });
}

function queueUpdateScripts() {
    if (changeTimeout !== null) {
        clearTimeout(changeTimeout);
    }

    changeTimeout = setTimeout(function () {
        updatePromise = updatePromise.then(function () {
            // Remove all files from queue and update them
            var filePaths = changeQueue.splice(0, changeQueue.length);
            updateScripts(filePaths);
        }).fail(function (err) {
            console.error(err);
            // Eat error
        });
    }, UPDATE_INTERVAL);
}

setInterval(function () {
    collectLiveScripts().then(function (liveScripts_) {
        liveScripts = liveScripts_;
    }).end()
}, 2000);
